When to use JSX.Element vs ReactNode vs ReactElement? 
https://stackoverflow.com/questions/58123398/when-to-use-jsx-element-vs-reactnode-vs-reactelement
I am currently migrating a React application to TypeScript. So far, this works pretty well, but I have a problem with the return types of my render functions respectively my function components. So far, I had always used JSX.Element as return type, now this doesn't work any more if a component decides to not render anything, i.e. return null, since null is no valid value for JSX.Element. This was the beginning of my journey, because now I searched the web and found that you should use ReactNode instead, which also includes null and also a few other things that can happen. This seemed to be the better bet. However, now when creating a function component, TypeScript complains about the ReactNode type. Again, after some searching I found, that for function components you should use ReactElement instead. However, if I do so, the compatibility issue is gone, but now TypeScript again complains about null not being a valid value. So, to cut a long story short, I have three questions: What is the difference between JSX.Element, ReactNode and ReactElement? Why do the render methods of class components return ReactNode, but function components return ReactElement? How do I solve this with respect to null? javascript reactjs typescript share improve this question follow edited Oct 6 '19 at 7:53 jonrsharpe 95.3k1919 gold badges171171 silver badges320320 bronze badges asked Sep 26 '19 at 19:18 Golo Roden 107k7575 gold badges250250 silver badges371371 bronze badges 1 I'm surprised this would come up, since usually you don't need to specify the return type with components. What type signature are you doing for the components? Should look something like class Example extends Component <exampleprops>{ for classes, and const Example: FunctionComponent <exampleprops>= (props) => { for function components (where ExampleProps is an interface for the expected props). And then these types have enough information that the return type can be inferred. – Nicholas Tower Sep 26 '19 at 19:36 The types are defined here – Jonas Wilms Sep 26 '19 at 19:38 1 @NicholasTower Our linting rules enforce explicitly providing the return type, and that's why this comes up (which IMHO is a good thing, because you think way more about what you do, which helps understanding, than if you just let the compiler infer everything). – Golo Roden Sep 26 '19 at 19:42 Fair enough, i didn't think of linting rules. – Nicholas Tower Sep 26 '19 at 19:43 @JonasWilms Thanks for the link, but I don't think that this answers my questions. – Golo Roden Sep 26 '19 at 19:43 add a comment 2 Answers 180 What is the difference between JSX.Element, ReactNode and ReactElement? A ReactElement is an object with a type and props. interface ReactElement

= string | JSXElementConstructor<any>> { type: T; props: P; key: Key | null; } A ReactNode is a ReactElement, a ReactFragment, a string, a number or an array of ReactNodes, or null, or undefined, or a boolean: type ReactText = string | number; type ReactChild = ReactElement | ReactText; interface ReactNodeArray extends Array <reactnode>{} type ReactFragment = {} | ReactNodeArray; type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined; JSX.Element is a ReactElement, with the generic type for props and type being any. It exists, as various libraries can implement JSX in their own way, therefore JSX is a global namespace that then gets set by the library, React sets it like this: declare global { namespace JSX { interface Element extends React.ReactElement <any, any="">{ } } } By example:</any,></reactnode></any>

// <- ReactElement = JSX.Element <custom>// <- ReactElement = JSX.Element {true && "test"} // <- ReactNode</custom>

Why do the render methods of class components return ReactNode, but function components return ReactElement? Indeed, they do return different things. Components return: render(): ReactNode; And functions are "stateless components": interface StatelessComponent

{ (props: P & { children?: ReactNode }, context?: any): ReactElement | null; // ... doesn't matter } This is actually due to historical reasons. How do I solve this with respect to null? Type it as ReactElement | null just as react does. Or let Typescript infer the type. source for the types share improve this answer follow edited Apr 9 '20 at 6:38 answered Sep 26 '19 at 19:54 Jonas Wilms 100k1010 gold badges8888 silver badges108108 bronze badges Thanks for the detailed answer! This perfectly answers question 1, but still leaves questions 2 and 3 unanswered. Can you provide some guidance on them, too, please? – Golo Roden Sep 26 '19 at 19:58 @goloRoden sure, I'm just a bit tired right now and it takes some time to scroll through the types on a mobile ... ;) – Jonas Wilms Sep 26 '19 at 20:10 Hi @JonasWilms. Regarding "They don't. ReactComponent is defined as: render(): JSX.Element | null | false;", where are you seeing that? It looks like it returns ReactNode to me (github.com/DefinitelyTyped/DefinitelyTyped/blob/… ) Also minor typo, I think ReactComponent should be React.Component or Component. – Mark Doliner Dec 19 '19 at 5:23 @MarkDoliner Weird, I could swear that I copied that type out of the file ... Whatever, you're totally right, I'll edit – Jonas Wilms Dec 19 '19 at 13:05 Guys is there any official documentation of the react && typescript somewhere on the web? – Goran_Ilic_Ilke Aug 17 '20 at 17:50 add a comment 30 1.) What is the difference between JSX.Element, ReactNode and ReactElement? ReactElement and JSX.Element are the result of invoking React.createElement directly or via JSX transpilation. It is an object with type, props and key. JSX.Element is ReactElement, whose props and type have type any, so they are more or less the same. const jsx =

<div>hello</div>

const ele = React.createElement("div", null, "hello"); ReactNode is used as return type for render() in class components. It also is the default type for children attribute with PropsWithChildren. const Comp: FunctionComponent = props =>

<div>{props.children}</div>

// children?: React.ReactNode It looks more complicated in the React type declarations, but is equivalent to: type ReactNode = {} | null | undefined; // super type `{}` has absorbed *all* other types, which are sub types of `{}` // so it is a very "broad" type (I don't want to say useless...) You can assign almost everything to ReactNode. I usually would prefer stronger types, but there might be some valid cases to use it. 2.) Why do the render methods of class components return ReactNode, but function components return ReactElement? tl;dr: It is a current TS type incompatibility not related to core React. TS class component: returns ReactNode with render(), more permissive than React/JS TS function component: returns JSX.Element | null, more restrictive than React/JS In principle, render() in React/JS class components supports the same return types as a function component. With regard to TS, the different types are a type inconsistency still kept due to historical reasons and the need for backwards-compatibility. Ideally a valid return type would probably look more like this: type ComponentReturnType = ReactElement | Array <componentreturntype>| string | number | boolean | null // Note: undefined is invalid 3.) How do I solve this with respect to null? Some options: // Use type inference; inferred return type is `JSX.Element | null` const MyComp1 = ({ condition }: { condition: boolean }) => condition ?

<div>Hello</div>

: null // Use explicit function return types; Add `null`, if needed const MyComp2 = (): JSX.Element =>

<div>Hello</div>

; const MyComp3 = (): React.ReactElement =>

<div>Hello</div>

; // Option 3 is equivalent to 2 + we don't need to use a global (JSX namespace) // Use built-in `FunctionComponent` or `FC` type const MyComp4: React.FC <myprops>= () =>

<div>Hello</div>

; Note: Avoiding React.FC won't save you from the JSX.Element | null return type restriction. Create React App recently dropped React.FC from its template, as it has some quirks like an implicit {children?: ReactNode} type definition. So using React.FC sparingly might be preferable. In edge cases, you can add a type assertion or Fragments as workaround: const MyCompFragment: FunctionComponent = () => <>"Hello" const MyCompCast: FunctionComponent = () => "Hello" as any // alternative to `as any`: `as unknown as JSX.Element | null`</myprops></componentreturntype></exampleprops></exampleprops>